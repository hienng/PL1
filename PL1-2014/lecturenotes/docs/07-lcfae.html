<!DOCTYPE html>
<html>
<head>
    <title>07-lcfae.scala</title>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <style type="text/css">
        /*--------------------- Layout and Typography ----------------------------*/
        body {
            font-family: 'Palatino Linotype', 'Book Antiqua', Palatino, FreeSerif, serif;
            font-size: 15px;
            line-height: 22px;
            color: #252519;
            margin: 0; padding: 0;
        }
        a {
            color: #261a3b;
        }
        a:visited {
            color: #261a3b;
        }
        p {
            margin: 0 0 15px 0;
        }
        h4, h5, h6 {
            color: #333;
            padding: 6px 0 6px 0;
            font-size: 13px;
        }
        h2, h3 {
            padding-bottom: 15px;
            color: #000;
            overflow: hidden;
        }
        h1 {
            /*padding-top: 40px;*/
            padding-bottom: 15px;
            color: #000;
        }
        #container {
            position: relative;
        }
        /*#background {
            position: fixed;
            top: 0; left: 525px; right: 0; bottom: 0;
            background: #f5f5ff;
            border-left: 1px solid #e5e5ee;
            z-index: -1;
        }*/
        #jump_to, #jump_page {
            background: white;
            -webkit-box-shadow: 0 0 25px #777; -moz-box-shadow: 0 0 25px #777;
            -webkit-border-bottom-left-radius: 5px; -moz-border-radius-bottomleft: 5px;
            font: 10px Arial;
            text-transform: uppercase;
            cursor: pointer;
            text-align: right;
        }
        #jump_to, #jump_wrapper {
            position: fixed;
            right: 0; top: 0;
            padding: 5px 10px;
        }
        #jump_wrapper {
            padding: 0;
            display: none;
        }
        #jump_to:hover #jump_wrapper {
            display: block;
        }
        #jump_page {
            padding: 5px 0 3px;
            margin: 0 0 25px 25px;
        }
        #jump_page .source {
            display: block;
            padding: 5px 10px;
            text-decoration: none;
            border-top: 1px solid #eee;
        }
        #jump_page .source:hover {
            background: #f5f5ff;
        }
        #jump_page .source:first-child {
        }
        table td {
            border: 0;
            outline: 0;
        }
        td.docs, th.docs {
            max-width: 450px;
            min-width: 450px;
            min-height: 5px;
            padding: 10px 25px 1px 50px;
            overflow-x: hidden;
            vertical-align: top;
            text-align: left;
        }
        .docs pre {
            margin: 15px 0 15px;
            padding-left: 15px;
        }
        .docs p tt, .docs p code, .doc code {
            background: #f8f8ff;
            border: 1px solid #dedede;
            font-size: 12px;
            padding: 0 0.2em;
        }
        .pilwrap {
            position: relative;
        }
        .pilcrow {
            font: 12px Arial;
            text-decoration: none;
            color: #454545;
            position: absolute;
            top: 3px; left: -20px;
            padding: 1px 2px;
            opacity: 0;
            -webkit-transition: opacity 0.2s linear;
        }
        td.docs:hover .pilcrow {
            opacity: 1;
        }
        td.code, th.code {
            padding: 10px 10px 10px 50px;
            width: 100%;
            vertical-align: top;
            background: #f5f5ff;
            border-left: 1px solid #e5e5ee;
        }
        pre, tt, code {
            font-size: 12px; line-height: 18px;
            font-family: Menlo, Monaco, Consolas, "Lucida Console", monospace;
            margin: 0; padding: 0;
        }

        /*---------------------- Prettify Syntax Highlighting -----------------------------*/
        .str{color:#080}.kwd{color:#008}.com{color:#800}.typ{color:#606}.lit{color:#066}.pun{color:#660}.pln{color:#000}.tag{color:#008}.atn{color:#606}.atv{color:#080}.dec{color:#606}pre.prettyprint{padding:2px;border:1px solid #888}ol.linenums{margin-top:0;margin-bottom:0}li.L0,li.L1,li.L2,li.L3,li.L5,li.L6,li.L7,li.L8{list-style:none}li.L1,li.L3,li.L5,li.L7,li.L9{background:#eee}@media print{.str{color:#060}.kwd{color:#006;font-weight:bold}.com{color:#600;font-style:italic}.typ{color:#404;font-weight:bold}.lit{color:#044}.pun{color:#440}.pln{color:#000}.tag{color:#006;font-weight:bold}.atn{color:#404}.atv{color:#060}}

        table.doc { margin-bottom: 20px; }
        td.doc { border-bottom: 1px dashed #708090; }
        td.param { font-weight: bold; }
        td.return { font-weight: bold; text-decoration: underline; }
    </style>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/prettify/r224/prettify.js" type="text/javascript"></script>
    <script src="https://google-code-prettify.googlecode.com/svn/trunk/src/lang-scala.js" type="text/javascript"></script>
</head>

<body onload="prettyPrint()">
<div id="container">
    <div id="background"></div>
    <div id="jump_to">
        Jump To &hellip;
        <div id="jump_wrapper">
            <div id="jump_page">
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/01-intro.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/01-intro.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/02-desugaring.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/02-desugaring.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/03-ae.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/03-ae.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/04-wae.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/04-wae.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/05-f1wae.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/05-f1wae.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/06-fae.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/06-fae.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/07-lcfae.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/07-lcfae.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/08-rcfae.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/08-rcfae.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/09-bcfae.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/09-bcfae.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/10-gc.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/10-gc.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/11-syntacticvsmeta.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/11-syntacticvsmeta.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/12-churchencoding.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/12-churchencoding.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/13-continuations-1.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/13-continuations-1.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/14-continuations-2.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/14-continuations-2.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/17-firstclasscontinuations.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/17-firstclasscontinuations.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/18-monads.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/18-monads.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/19-monads.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/19-monads.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/20-iomonad.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/20-iomonad.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/21-defunctionalization.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/21-defunctionalization.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/22-typesystems.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/22-typesystems.html
                </a>
                
            </div>
        </div>
    </div>

    <table cellpadding="0" cellspacing="0">
        <thead>
        <tr>
            <th class="docs">
                <h1>07-lcfae.scala</h1>
            </th>
            <th class="code"></th>
        </tr>
        </thead>
        <tbody>
        
        <tr id="section_0">
            <td class="docs">
                <div class="pilwrap">
                    <a class="pilcrow" href="#section_0">&#182;</a>
                </div>
                <h1>Lazy Evaluation</h1>
<h2>Motivation for Lazy Evaluation</h2>
<p>read &ldquo;Why Functional Programming Matters&rdquo; by John Hughes available at http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html</p>
<h2>What lazy evaluation means</h2>
<p>The choice of evaluation strategy is a purely semantic change that requires no change to the syntax.
<br  />For this reason we reuse the syntactic definitions of FAE, hence <code>:load 5-fae.scala</code> before executing this script or uncomment the previous line.</p>
<p>Before we discuss lazy evaluation, we will first discuss a related evaluation strategy, call-by-name.</p>
<p>Call-by-name can be explained very succintly in the substitution-based interpreter: Instead of evaluating the argument &ldquo;a&rdquo; in the &ldquo;App&rdquo; case before substitution, we substitute the unevaluated argument into the body. The rest remains exactly the same.</p>

            </td></tr><tr>
            <td class="code">
                <pre><code class='prettyprint lang-scala'>def evalcbn(e: Exp) : Exp = e match {
  case Id(v) =&gt; sys.error(&quot;unbound identifier: &quot; + v.name)
  case Add(l,r) =&gt; (evalcbn(l), evalcbn(r)) match {
                     case (Num(x),Num(y)) =&gt; Num(x+y)
                     case _ =&gt; sys.error(&quot;can only add numbers&quot;)
                    }
  case App(f,a) =&gt; evalcbn(f) match {
     case Fun(x,body) =&gt; evalcbn( subst(body,x, a)) // no evaluation of a!
     case _ =&gt; sys.error(&quot;can only apply functions&quot;)
  }
  case _ =&gt; e 
}

</code></pre>
            </td>
        </tr>
        
        <tr id="section_1">
            <td class="docs">
                <div class="pilwrap">
                    <a class="pilcrow" href="#section_1">&#182;</a>
                </div>
                <p>Does this change the semantics, or is it just an implementation detail? In other words, is <code>eval(e) == evalcbn(e)</code> for all <code>e</code> ? Let's try two former test cases.</p>

            </td></tr><tr>
            <td class="code">
                <pre><code class='prettyprint lang-scala'>assert( evalcbn(test) == eval(test))
assert(evalcbn(test2) == eval(test2))

</code></pre>
            </td>
        </tr>
        
        <tr id="section_2">
            <td class="docs">
                <div class="pilwrap">
                    <a class="pilcrow" href="#section_2">&#182;</a>
                </div>
                <p>One can formally prove that if eval and evalcbn both produce a number then the numbers are equal. Do they also agree if they produce a function?</p>
<p>Not necessarily. Consider:</p>

            </td></tr><tr>
            <td class="code">
                <pre><code class='prettyprint lang-scala'>val test3 = App(Fun('f,Fun('x,App('f,'x))),Add(1,2)) 

assert(eval(test3) == Fun('x,App(Num(3),Id('x))))
assert(evalcbn(test3) == Fun('x,App(Add(Num(1),Num(2)),Id('x))))

</code></pre>
            </td>
        </tr>
        
        <tr id="section_3">
            <td class="docs">
                <div class="pilwrap">
                    <a class="pilcrow" href="#section_3">&#182;</a>
                </div>
                <p>However, if both produce a function, then the functions &ldquo;behave&rdquo; the same. More specifically, the function bodies produced by evalcbn may be  &ldquo;more evaluated&rdquo; than those produced by eval. If we would evaluate within function bodies (also called evaluation &ldquo;under a lambda&rdquo;) - which our interpreters do not do - we could produce the expression returned from eval from the expression returned by evalcbn. This kind of equivalence is also called &ldquo;beta-equivalence&rdquo;.</p>
<p>Most importantly, however, eval and evalcbn differ with regard to their termination behavior. We have seen that omega is a diverging expression. In eval, the term</p>

            </td></tr><tr>
            <td class="code">
                <pre><code class='prettyprint lang-scala'> val test4 = App(Fun('x,5),omega)

</code></pre>
            </td>
        </tr>
        
        <tr id="section_4">
            <td class="docs">
                <div class="pilwrap">
                    <a class="pilcrow" href="#section_4">&#182;</a>
                </div>
                <p>is hence also diverging. In contrast:</p>

            </td></tr><tr>
            <td class="code">
                <pre><code class='prettyprint lang-scala'>assert(evalcbn(test4) == Num(5))

</code></pre>
            </td>
        </tr>
        
        <tr id="section_5">
            <td class="docs">
                <div class="pilwrap">
                    <a class="pilcrow" href="#section_5">&#182;</a>
                </div>
                <h2>Extra material: Infinite lists in FAE (not relevant for exam)</h2>
<p>Using our call-by-name interpreter, we can express the same kinds of programming patterns that we have tried in Haskell, such as infinite lists.</p>
<p>We do not have direct support for lists, but we can encode lists. This kind of encoding is called <em>Church encoding</em>.</p>

            </td></tr><tr>
            <td class="code">
                <pre><code class='prettyprint lang-scala'>val nil = Fun('c, Fun('e, 'e))
val cons  = Fun('x, Fun('xs, Fun('c, Fun('e, App(App('c, 'x), App(App('xs, 'c),'e))))))
/* For instance, the list 1,2,3 is encoded as: */
val list123 = App(App('cons,1),App(App('cons,2),App(App('cons,3), 'nil)))
/* The map function on lists becomes :*/
val maplist = Fun('f, Fun('l, App(App('l, Fun('x, Fun('xs, App(App('cons, App('f,'x)),'xs)))), 'nil)))
</code></pre>
            </td>
        </tr>
        
        <tr id="section_6">
            <td class="docs">
                <div class="pilwrap">
                    <a class="pilcrow" href="#section_6">&#182;</a>
                </div>
                <p>For instance, we can map the successor function over the 1,2,3 list.</p>

            </td></tr><tr>
            <td class="code">
                <pre><code class='prettyprint lang-scala'>val test5 = wth('cons,cons, 
            wth('nil, nil, 
            wth('maplist, maplist,
            App(App('maplist, Fun('x, Add('x,1))), list123))))
</code></pre>
            </td>
        </tr>
        
        <tr id="section_7">
            <td class="docs">
                <div class="pilwrap">
                    <a class="pilcrow" href="#section_7">&#182;</a>
                </div>
                <p>Since it is somewhat difficult to print out the resulting list in our primitive language we construct the result we expect explicitly.</p>

            </td></tr><tr>
            <td class="code">
                <pre><code class='prettyprint lang-scala'>val test5res = wth('cons,cons, 
               wth('nil, nil, 
                 App(App('cons,2),App(App('cons,3),App(App('cons,4), 'nil)))))
assert(eval(test5) == eval(test5res))     
</code></pre>
            </td>
        </tr>
        
        <tr id="section_8">
            <td class="docs">
                <div class="pilwrap">
                    <a class="pilcrow" href="#section_8">&#182;</a>
                </div>
                <p>Using evalcbn instead of eval the assertion does not hold (why?), but the results are beta-equivalent.</p>
<p>We can also construct infinite lists. To this end, we need some form of recursion. We choose the standard fixed-point operator Y. This operator only works under call-by-name or other so-called &ldquo;non-strict&rdquo; evaluation strategies.</p>

            </td></tr><tr>
            <td class="code">
                <pre><code class='prettyprint lang-scala'>val y = Fun('f, App(Fun('x,App('f, App('x,'x))), Fun('x,App('f,App('x,'x)))))

</code></pre>
            </td>
        </tr>
        
        <tr id="section_9">
            <td class="docs">
                <div class="pilwrap">
                    <a class="pilcrow" href="#section_9">&#182;</a>
                </div>
                <p>Using Y, we can construct infinite lists, such as the list of all natural numbers.</p>

            </td></tr><tr>
            <td class="code">
                <pre><code class='prettyprint lang-scala'>val allnats = App(App('y, Fun('nats, Fun('n, App(App('cons,'n), App('nats, Add('n,1)))))),1)

</code></pre>
            </td>
        </tr>
        
        <tr id="section_10">
            <td class="docs">
                <div class="pilwrap">
                    <a class="pilcrow" href="#section_10">&#182;</a>
                </div>
                <p>We can also perform standard computations on infinite lists, such as mapping the successor function over it.</p>

            </td></tr><tr>
            <td class="code">
                <pre><code class='prettyprint lang-scala'>val list2toinfty = wth('cons,cons, 
                   wth('nil, nil, 
                   wth('y, y, 
                   wth('maplist, maplist,
                      App(App('maplist, Fun('x, Add('x,1))), allnats)))))
</code></pre>
            </td>
        </tr>
        
        <tr id="section_11">
            <td class="docs">
                <div class="pilwrap">
                    <a class="pilcrow" href="#section_11">&#182;</a>
                </div>
                <p>Of course, <code>list2toinfty</code> diverges when we use <code>eval</code>, but it works fine with <code>evalcbn</code>. It is hard to verify the result due to an almost unreadable output. Hence we propose the following</p>
<p>Exercise: Extend the language such that you can implement the &ldquo;take&rdquo; function as known from Haskell within the language  (if0-expressions or something like it are needed for that). Now add a &ldquo;print&rdquo; function that prints a number on the console. Use it to display the first 3 list elements of test2toinfty are 2,3,4.</p>
<p>&ndash; end of extra material &ndash;</p>

            </td></tr><tr>
            <td class="code">
                <pre><code class='prettyprint lang-scala'></code></pre>
            </td>
        </tr>
        
        <tr id="section_12">
            <td class="docs">
                <div class="pilwrap">
                    <a class="pilcrow" href="#section_12">&#182;</a>
                </div>
                <h2>Environment-based lazy evaluation</h2>
<p>Let us now consider the question how we can implement call-by-name in the environment-based interpreter. Translating the idea of not evaluating the function argument to the environment-based version seems to  suggest that the environment should map identifiers to expression instead of values.</p>
<p>However, we run into the same problems that we had with first-class functions before we introduced closures: What happens to the deferred substitutions that still have to be applied in the function argument? If we discard the environment in which the function argument was defined we again introduce a variant of dynamic scoping.</p>
<p>Hence, like for closures, we need to store the environment together with the expression. We call such a  pair a <em>thunk</em>. An environment hence becomes a mapping from symbols to thunks. Note that environments and thunks are hence mutually recursive. In Scala, we can hence not use type definitions of the form</p>
<p>type Thunk = (Exp, Env)
<br  />type Env = Map[Symbol, Thunk]</p>
<p>Instead, we use a Scala class Env to express this recursion.</p>
<p>Since we want to experiment with different variants of how to generate and evaluate thunks we first create a parameterizable variant of the evaluator that leaves open how to</p>
<ol>
<li>represent thunks (type Thunk)</li>
<li>create thunks (method delay)</li>
<li>evaluate thunks (method force).</li>
</ol>
<p>Hint: Research on the internet what abstract type members in Scala are.  For instance, here: http://www.scala-lang.org/node/105</p>

            </td></tr><tr>
            <td class="code">
                <pre><code class='prettyprint lang-scala'>trait CBN {
    type Thunk
    
    case class Env(map: Map[Symbol, Thunk]) {
      def apply(key: Symbol) = map.apply(key)
      def +(other: (Symbol, Thunk)) : Env = Env(map+other)
    }

    def delay(e: Exp, env: Env) : Thunk
    def force(t: Thunk) : Value

    // since values also depend on Env and hence on Thunk they need to
    // be defined within this trait    
    sealed abstract class Value
    case class NumV(n: Int) extends Value
    case class ClosureV(f: Fun, env: Env) extends Value 
    def eval(e: Exp, env: Env) : Value = e match {
      case Id(x) =&gt; force(env(x)) // force evaluation of thunk if identifier is evaluated
      case Add(l,r) =&gt; {
        (eval(l,env), eval(r,env)) match {
          case (NumV(v1),NumV(v2)) =&gt; NumV(v1+v2)
          case _ =&gt; sys.error(&quot;can only add numbers&quot;)
        }
      }
      case App(f,a) =&gt; eval(f,env) match {
        // delay argument expression and add it to environment of the closure
        case ClosureV(f,cenv) =&gt; eval(f.body, cenv + (f.param -&gt; delay(a,env)))
        case _ =&gt; sys.error(&quot;can only apply functions&quot;)
      }
      case Num(n) =&gt; NumV(n)
      case f@Fun(x,body) =&gt; ClosureV(f,env)
    }
}
</code></pre>
            </td>
        </tr>
        
        <tr id="section_13">
            <td class="docs">
                <div class="pilwrap">
                    <a class="pilcrow" href="#section_13">&#182;</a>
                </div>
                <p>Let's now create an instance of CBN that corresponds to the substitution-based call-by-name interpreter. A thunk is just a pair of expression and environment. Forcing a thunk just evaluates it in the stored environment.</p>
<p>To understand what is going on during evaluation of tests we trace argument evaluation by a  printout to the console.</p>

            </td></tr><tr>
            <td class="code">
                <pre><code class='prettyprint lang-scala'>object CallByName extends CBN {
  type Thunk = (Exp,Env)
  def delay(e: Exp, env: Env) = (e,env)
  def force(t: Thunk) = {
    println(&quot;Forcing evaluation of expression: &quot;+t._1)
    eval(t._1,t._2)
  }
}

assert(CallByName.eval(test, CallByName.Env(Map.empty)) == CallByName.NumV(12))
</code></pre>
            </td>
        </tr>
        
        <tr id="section_14">
            <td class="docs">
                <div class="pilwrap">
                    <a class="pilcrow" href="#section_14">&#182;</a>
                </div>
                <h2>Call-by-need</h2>
<p>Call-by-name is rather wasteful: If an argument is used n times in the body, the argument expression is re-evaluated n-times. For instance, in</p>

            </td></tr><tr>
            <td class="code">
                <pre><code class='prettyprint lang-scala'>val cbntest = wth('double, Fun('x, Add('x,'x)),
               App('double, Add(2,3)))
</code></pre>
            </td>
        </tr>
        
        <tr id="section_15">
            <td class="docs">
                <div class="pilwrap">
                    <a class="pilcrow" href="#section_15">&#182;</a>
                </div>
                <p>the sum of 2 and 3 is computed twice.  If the argument is passed again to another function, this may lead to an exponential blow-up.</p>
<p>Example:</p>

            </td></tr><tr>
            <td class="code">
                <pre><code class='prettyprint lang-scala'>val blowup  = wth('a, Fun('x, Add('x,'x)),
              wth('b, Fun('x, Add(App('a,'x), App('a,'x))),
              wth('c, Fun('x, Add(App('b,'x), App('b,'x))),
              wth('d, Fun('x, Add(App('c,'x), App('c,'x))),
              wth('e, Fun('x, Add(App('d,'x), App('d,'x))),
              wth('f, Fun('x, Add(App('e,'x), App('e,'x))),
              App('f, Add(2,3))))))))
</code></pre>
            </td>
        </tr>
        
        <tr id="section_16">
            <td class="docs">
                <div class="pilwrap">
                    <a class="pilcrow" href="#section_16">&#182;</a>
                </div>
                <p>Can we do better? Yes, by caching the value when the argument expression is evaluated for the first time. This evaluation strategy is called <em>call-by-need</em>.</p>
<p>Caching is easy to implement in Scala:</p>

            </td></tr><tr>
            <td class="code">
                <pre><code class='prettyprint lang-scala'>object CallByNeed extends CBN {
  case class MemoThunk(e: Exp, env: Env) {
    var cache: Value = null
  }
  type Thunk = MemoThunk
  def delay(e: Exp, env: Env) = MemoThunk(e,env)
  def force(t: Thunk) = {
    if (t.cache == null) {
      println(&quot;Forcing evaluation of expression: &quot;+t.e)
      t.cache = eval(t.e, t.env)
    } else println (&quot;Reusing cached value &quot;+t.cache+&quot; for expression &quot;+t.e)
    t.cache
  }
}

</code></pre>
            </td>
        </tr>
        
        <tr id="section_17">
            <td class="docs">
                <div class="pilwrap">
                    <a class="pilcrow" href="#section_17">&#182;</a>
                </div>
                <p>For instance, compare call-by-need and call-by-name in cbntest or blowup.</p>
<p>However, the meta-language (i.e., the subset of Scala features) used in the interpreter has become more complicated: Since we are using mutation, the order of evaluation and aliasing of object references becomes important. Luckily,  call-by-need agrees with call-by-name with regard to produced values and termination behavior, hence it is usually not necessary to reason about programs with the* call-by-need semantics. If, however, one wants to reason about the performance of a program in a call-by-need setting, one has to take these additional complications into account. In practice, it is even worse, since languages like Haskell perform additional optimizations that, for instance, switch to call-by-value if an analysis can determine that an argument will definitely be used (lookup &ldquo;strictness analysis&rdquo;).</p>
<p>Topics for class discussion:</p>
<ul>
<li>Is it a good idea to mix a language with implicit mutation (such as Java, Scala, C++, Python, &hellip;) with lazy evaluation?</li>
<li>How can one simulate lazy evaluation in an eager language? Basic idea: 'Lambda' as evaluation firewall.</li>
</ul>

            </td></tr><tr>
            <td class="code">
                <pre><code class='prettyprint lang-scala'></code></pre>
            </td>
        </tr>
        
        </tbody>
    </table>
</div>
</body>
</html>
