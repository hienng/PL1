<!DOCTYPE html>
<html>
<head>
    <title>05-f1wae.scala</title>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <style type="text/css">
        /*--------------------- Layout and Typography ----------------------------*/
        body {
            font-family: 'Palatino Linotype', 'Book Antiqua', Palatino, FreeSerif, serif;
            font-size: 15px;
            line-height: 22px;
            color: #252519;
            margin: 0; padding: 0;
        }
        a {
            color: #261a3b;
        }
        a:visited {
            color: #261a3b;
        }
        p {
            margin: 0 0 15px 0;
        }
        h4, h5, h6 {
            color: #333;
            padding: 6px 0 6px 0;
            font-size: 13px;
        }
        h2, h3 {
            padding-bottom: 15px;
            color: #000;
            overflow: hidden;
        }
        h1 {
            /*padding-top: 40px;*/
            padding-bottom: 15px;
            color: #000;
        }
        #container {
            position: relative;
        }
        /*#background {
            position: fixed;
            top: 0; left: 525px; right: 0; bottom: 0;
            background: #f5f5ff;
            border-left: 1px solid #e5e5ee;
            z-index: -1;
        }*/
        #jump_to, #jump_page {
            background: white;
            -webkit-box-shadow: 0 0 25px #777; -moz-box-shadow: 0 0 25px #777;
            -webkit-border-bottom-left-radius: 5px; -moz-border-radius-bottomleft: 5px;
            font: 10px Arial;
            text-transform: uppercase;
            cursor: pointer;
            text-align: right;
        }
        #jump_to, #jump_wrapper {
            position: fixed;
            right: 0; top: 0;
            padding: 5px 10px;
        }
        #jump_wrapper {
            padding: 0;
            display: none;
        }
        #jump_to:hover #jump_wrapper {
            display: block;
        }
        #jump_page {
            padding: 5px 0 3px;
            margin: 0 0 25px 25px;
        }
        #jump_page .source {
            display: block;
            padding: 5px 10px;
            text-decoration: none;
            border-top: 1px solid #eee;
        }
        #jump_page .source:hover {
            background: #f5f5ff;
        }
        #jump_page .source:first-child {
        }
        table td {
            border: 0;
            outline: 0;
        }
        td.docs, th.docs {
            max-width: 450px;
            min-width: 450px;
            min-height: 5px;
            padding: 10px 25px 1px 50px;
            overflow-x: hidden;
            vertical-align: top;
            text-align: left;
        }
        .docs pre {
            margin: 15px 0 15px;
            padding-left: 15px;
        }
        .docs p tt, .docs p code, .doc code {
            background: #f8f8ff;
            border: 1px solid #dedede;
            font-size: 12px;
            padding: 0 0.2em;
        }
        .pilwrap {
            position: relative;
        }
        .pilcrow {
            font: 12px Arial;
            text-decoration: none;
            color: #454545;
            position: absolute;
            top: 3px; left: -20px;
            padding: 1px 2px;
            opacity: 0;
            -webkit-transition: opacity 0.2s linear;
        }
        td.docs:hover .pilcrow {
            opacity: 1;
        }
        td.code, th.code {
            padding: 10px 10px 10px 50px;
            width: 100%;
            vertical-align: top;
            background: #f5f5ff;
            border-left: 1px solid #e5e5ee;
        }
        pre, tt, code {
            font-size: 12px; line-height: 18px;
            font-family: Menlo, Monaco, Consolas, "Lucida Console", monospace;
            margin: 0; padding: 0;
        }

        /*---------------------- Prettify Syntax Highlighting -----------------------------*/
        .str{color:#080}.kwd{color:#008}.com{color:#800}.typ{color:#606}.lit{color:#066}.pun{color:#660}.pln{color:#000}.tag{color:#008}.atn{color:#606}.atv{color:#080}.dec{color:#606}pre.prettyprint{padding:2px;border:1px solid #888}ol.linenums{margin-top:0;margin-bottom:0}li.L0,li.L1,li.L2,li.L3,li.L5,li.L6,li.L7,li.L8{list-style:none}li.L1,li.L3,li.L5,li.L7,li.L9{background:#eee}@media print{.str{color:#060}.kwd{color:#006;font-weight:bold}.com{color:#600;font-style:italic}.typ{color:#404;font-weight:bold}.lit{color:#044}.pun{color:#440}.pln{color:#000}.tag{color:#006;font-weight:bold}.atn{color:#404}.atv{color:#060}}

        table.doc { margin-bottom: 20px; }
        td.doc { border-bottom: 1px dashed #708090; }
        td.param { font-weight: bold; }
        td.return { font-weight: bold; text-decoration: underline; }
    </style>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/prettify/r224/prettify.js" type="text/javascript"></script>
    <script src="https://google-code-prettify.googlecode.com/svn/trunk/src/lang-scala.js" type="text/javascript"></script>
</head>

<body onload="prettyPrint()">
<div id="container">
    <div id="background"></div>
    <div id="jump_to">
        Jump To &hellip;
        <div id="jump_wrapper">
            <div id="jump_page">
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/01-intro.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/01-intro.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/02-desugaring.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/02-desugaring.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/03-ae.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/03-ae.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/04-wae.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/04-wae.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/05-f1wae.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/05-f1wae.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/06-fae.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/06-fae.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/07-lcfae.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/07-lcfae.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/08-rcfae.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/08-rcfae.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/09-bcfae.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/09-bcfae.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/10-gc.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/10-gc.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/11-syntacticvsmeta.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/11-syntacticvsmeta.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/12-churchencoding.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/12-churchencoding.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/13-continuations-1.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/13-continuations-1.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/14-continuations-2.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/14-continuations-2.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/17-firstclasscontinuations.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/17-firstclasscontinuations.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/18-monads.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/18-monads.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/19-monads.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/19-monads.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/20-iomonad.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/20-iomonad.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/21-defunctionalization.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/21-defunctionalization.html
                </a>
                
                <a class="source" href="/Users/klaus/git/PL1-2014/lecturenotes/22-typesystems.html">
                    /Users/klaus/git/PL1-2014/lecturenotes/22-typesystems.html
                </a>
                
            </div>
        </div>
    </div>

    <table cellpadding="0" cellspacing="0">
        <thead>
        <tr>
            <th class="docs">
                <h1>05-f1wae.scala</h1>
            </th>
            <th class="code"></th>
        </tr>
        </thead>
        <tbody>
        
        <tr id="section_0">
            <td class="docs">
                <div class="pilwrap">
                    <a class="pilcrow" href="#section_0">&#182;</a>
                </div>
                <h1>First-Order Functions</h1>
<p>In the last lecture we have seen how we can give commonly occuring (sub)expressions a name via the &ldquo;with&rdquo; construct. Often, however, we can identify <em>patterns</em> of expressions that occur in many places, such as <code>5*5/2</code>, <code>7*7/2</code> and <code>3*3/2</code>, the common pattern being <code>x*x/2</code>. In this case, the abstraction capabilities of <code>with</code> are not sufficient.</p>
<p>One way to enable more powerful abstractions are <em>functions</em>. Depending on the context of use and the interaction with other language features (such as imperative features or objects), functions are also sometimes called <em>procedures</em> or <em>methods</em>.</p>
<p>Here we consider so-called first-order functions, that - unlike higher-order functions - are not expressions and can hence not be passed to or be returned from other functions. First-order functions are simply called by name.</p>
<p>To introduce first-order functions, we need two new things: The possibility to define functions, and the possibility to call functions. A call to a function is an expression, whereas functions are defined separately. Functions can have an arbitrary number of arguments.</p>
<p>The following definitions are the language we have analyzed so far</p>

            </td></tr><tr>
            <td class="code">
                <pre><code class='prettyprint lang-scala'>sealed abstract class Exp 
case class Num(n: Int) extends Exp
case class Add(lhs: Exp, rhs: Exp) extends Exp
case class Mul(lhs: Exp, rhs: Exp) extends Exp
case class Id(x: Symbol) extends Exp 
case class With(x: Symbol, xdef: Exp, body: Exp) extends Exp
/* We use implicits again to make example programs less verbose. */
implicit def num2exp(n: Int) = Num(n)
implicit def sym2exp(x: Symbol) = Id(x)

</code></pre>
            </td>
        </tr>
        
        <tr id="section_1">
            <td class="docs">
                <div class="pilwrap">
                    <a class="pilcrow" href="#section_1">&#182;</a>
                </div>
                <p>The new language constructs for first-order functions:</p>

            </td></tr><tr>
            <td class="code">
                <pre><code class='prettyprint lang-scala'>case class Call(f: Symbol, args: List[Exp]) extends Exp // functions are called by name

</code></pre>
            </td>
        </tr>
        
        <tr id="section_2">
            <td class="docs">
                <div class="pilwrap">
                    <a class="pilcrow" href="#section_2">&#182;</a>
                </div>
                <p>A function has a number of formal args and a body. A first-order function also
<br  />has a name. To make the invariant that there can only be one function for each
<br  />name explicit, we store functions in the form of a map from function names to FunDefs:</p>

            </td></tr><tr>
            <td class="code">
                <pre><code class='prettyprint lang-scala'>case class FunDef(args: List[Symbol], body: Exp)
type Funs = Map[Symbol,FunDef]

</code></pre>
            </td>
        </tr>
        
        <tr id="section_3">
            <td class="docs">
                <div class="pilwrap">
                    <a class="pilcrow" href="#section_3">&#182;</a>
                </div>
                <p>The substitution for the new language is a straightforward extension of the former one.</p>

            </td></tr><tr>
            <td class="code">
                <pre><code class='prettyprint lang-scala'>def subst(e: Exp,i: Symbol,v: Num) : Exp =  e match {
    case Num(n) =&gt; e
    case Id(x) =&gt; if (x == i) v else e
    case Add(l,r) =&gt; Add( subst(l,i,v), subst(r,i,v))
    case Mul(l,r) =&gt; Mul( subst(l,i,v), subst(r,i,v))
    case With(x,xdef,body) =&gt; With(x,
                                   subst(xdef,i,v),
                                   if (x == i) body else subst(body,i,v))
    case Call(f,args) =&gt; Call(f, args.map(subst(_,i,v)))
}

</code></pre>
            </td>
        </tr>
        
        <tr id="section_4">
            <td class="docs">
                <div class="pilwrap">
                    <a class="pilcrow" href="#section_4">&#182;</a>
                </div>
                <p>We will first study a &ldquo;reference interpreter&rdquo; based on substitution.
<br  />We pass the map of functions as an additional parameter.</p>

            </td></tr><tr>
            <td class="code">
                <pre><code class='prettyprint lang-scala'>def eval(funs: Funs, e: Exp) : Int = e match {
  case Num(n) =&gt; n
  case Id(x) =&gt; sys.error(&quot;unbound identifier: &quot; + x.name)
  case Add(l,r) =&gt; eval(funs,l) + eval(funs,r)
  case Mul(l,r) =&gt; eval(funs,l)eval(funs,r)
  case With(x, xdef, body) =&gt; eval(funs,subst(body,x,Num(eval(funs,xdef)))) 
  case Call(f,args) =&gt; {
     val fd = funs(f) // lookup function definition 
     val vargs = args.map( eval(funs,_)) // evaluate function arguments
     if (fd.args.size != vargs.size) sys.error(&quot;number of paramters in call to &quot; + f.name + &quot; does not match&quot;)
     // We construct the function body to be evaluated by subsequently substituting all formal
     // arguments with their respective argument values.
     // If we have only a single argument &quot;fd.arg&quot; and a single argument value &quot;varg&quot;, 
     // the next line of code is equivalent to:
     // val substbody = subst(fd.body, fd.arg, Num(varg))
     val substbody = fd.args.zip(vargs).foldLeft(fd.body)( (b,av) =&gt; subst(b,av._1,Num(av._2)))
     eval(funs,substbody)
  }   
}

</code></pre>
            </td>
        </tr>
        
        <tr id="section_5">
            <td class="docs">
                <div class="pilwrap">
                    <a class="pilcrow" href="#section_5">&#182;</a>
                </div>
                <p>Is the extension really so straightforward?  It can be seen in the last line of our definition for <code>subst</code> that variable substitution deliberately ignores the function name <code>f</code>.  The substitution for <code>f</code> instead is handled separately inside <code>eval</code>.  We say in this case that function names and variable names live in different &ldquo;name spaces&rdquo;.  An alternative would be to have them share one namespace.  As an exercise, think about how to support a common namespace for function names and variable names.</p>

            </td></tr><tr>
            <td class="code">
                <pre><code class='prettyprint lang-scala'>/* A test case */
val someFuns = Map( 'adder -&gt; FunDef(List('a,'b), Add('a,'b)),
                 'doubleadder -&gt; FunDef(List('a,'x), Add(Call('adder, List('a,5)),Call('adder, List('x,7)))))
assert( eval(someFuns,Call('doubleadder,List(2,3))) == 17)

</code></pre>
            </td>
        </tr>
        
        <tr id="section_6">
            <td class="docs">
                <div class="pilwrap">
                    <a class="pilcrow" href="#section_6">&#182;</a>
                </div>
                <h2>The scope of function definitions:</h2>
<p>As can be seen in the example above, each function can &ldquo;see&rdquo; the other functions. We say that in this language functions have a <em>global scope</em>.</p>
<p>Exercise: Can a function also invoke itself? Is this useful?</p>
<p>We will now study an environment-based version of the interpreter. To motivate environments, consider the following sample program:</p>

            </td></tr><tr>
            <td class="code">
                <pre><code class='prettyprint lang-scala'>val testProg = With('x, 1, With('y, 2, With('z, 3, Add('x,Add('y,'z)))))

</code></pre>
            </td>
        </tr>
        
        <tr id="section_7">
            <td class="docs">
                <div class="pilwrap">
                    <a class="pilcrow" href="#section_7">&#182;</a>
                </div>
                <p>When considering the <code>With</code> case of the interpreter, the interpreter will subsequently produce and evaluate the following intermediate expressions:</p>

            </td></tr><tr>
            <td class="code">
                <pre><code class='prettyprint lang-scala'>val testProgAfterOneStep     = With('y, 2, With('z, 3, Add(1,Add('y,'z))))
val testProgAfterTwoSteps    = With('z, 3, Add(1,Add(2,'z)))
val testProgAfterThreeSteps  = Add(1,Add(2,3))

</code></pre>
            </td>
        </tr>
        
        <tr id="section_8">
            <td class="docs">
                <div class="pilwrap">
                    <a class="pilcrow" href="#section_8">&#182;</a>
                </div>
                <p>At this point only pure arithmetic is left. But we see that the interpreter had to apply subsitution three times. In general, if the program size is n, then the interpreter may perform up to O(n) substitutions, each of which takes O(n) time. This quadratic complexity seems rather wasteful. Can we do better?</p>
<p>We can avoid the redundancy by deferring the substitutions until they are really needed. Concretely, we define a repository of deferred substitutions, called <em>environment</em>. It tells us which identifiers are supposed to be eventually substituted by which value. This idea is captured in the following type definition:</p>

            </td></tr><tr>
            <td class="code">
                <pre><code class='prettyprint lang-scala'> type Env = Map[Symbol,Int]

</code></pre>
            </td>
        </tr>
        
        <tr id="section_9">
            <td class="docs">
                <div class="pilwrap">
                    <a class="pilcrow" href="#section_9">&#182;</a>
                </div>
                <p>Initially, we have no substitutions to perform, so the repository is empty. Every time we encounter a construct (a with or application) that requires substitution, we augment the repository with one more entry, recording the identiﬁer’s name and the value (if eager) or expression (if lazy) it should eventually be substituted with. We continue to evaluate without actually performing the substitution.</p>
<p>This strategy breaks a key invariant we had established earlier, which is that any identiﬁer the interpreter could encounter must be free, for had it been bound, it would have already been substituted.  Now that we’re longer using the substitution-based model, we may encounter bound identiﬁers during interpretation.  How do we handle them?  We must substitute them by consulting the repository.</p>

            </td></tr><tr>
            <td class="code">
                <pre><code class='prettyprint lang-scala'>def evalWithEnv(funs: Funs, env: Env, e: Exp) : Int = e match {
  case Num(n) =&gt; n
  case Id(x) =&gt; env(x) // look up in repository of deferred substitutions
  case Add(l,r) =&gt; evalWithEnv(funs,env,l) + evalWithEnv(funs,env,r)
  case Mul(l,r) =&gt; evalWithEnv(funs,env,l)evalWithEnv(funs,env,r)
  case With(x, xdef, body) =&gt; evalWithEnv(funs,env+ ((x,evalWithEnv(funs,env,xdef))),body) 
  case Call(f,args) =&gt; {
     val fd = funs(f) // lookup function definition 
     val vargs = args.map(evalWithEnv(funs,env,_)) // evaluate function arguments
     if (fd.args.size != vargs.size) sys.error(&quot;number of paramters in call to &quot; + f.name + &quot; does not match&quot;)
     // We construct the environment by associating each formal argument to its actual value    
     val newenv = Map() ++ fd.args.zip(vargs)
     evalWithEnv(funs,newenv,fd.body)
  }   
}

assert( evalWithEnv(someFuns,Map.empty, Call('doubleadder,List(2,3))) == 17)

</code></pre>
            </td>
        </tr>
        
        <tr id="section_10">
            <td class="docs">
                <div class="pilwrap">
                    <a class="pilcrow" href="#section_10">&#182;</a>
                </div>
                <p>In the interpreter above, we have extended the empty environment when constructing <code>newenv</code>. A conceivable alternative is to extend <code>env</code> instead, like so:</p>

            </td></tr><tr>
            <td class="code">
                <pre><code class='prettyprint lang-scala'>def evalDynScope(funs: Funs, env: Env, e: Exp) : Int = e match {
  case Num(n) =&gt; n
  case Id(x) =&gt; env(x)
  case Add(l,r) =&gt; evalDynScope(funs,env,l) + evalDynScope(funs,env,r)
  case Mul(l,r) =&gt; evalDynScope(funs,env,l)evalDynScope(funs,env,r)
  case With(x, xdef, body) =&gt; evalDynScope(funs,env+ ((x,evalDynScope(funs,env,xdef))),body) 
  case Call(f,args) =&gt; {
     val fd = funs(f) 
     val vargs = args.map(evalDynScope(funs,env,_)) 
     if (fd.args.size != vargs.size) sys.error(&quot;number of paramters in call to &quot;+f+&quot; does not match&quot;)   
     val newenv = env ++ fd.args.zip(vargs) // extending env instead of Map() !!
     evalDynScope(funs,newenv,fd.body)
  }   
}

assert( evalDynScope(someFuns,Map.empty, Call('doubleadder,List(2,3))) == 17)

</code></pre>
            </td>
        </tr>
        
        <tr id="section_11">
            <td class="docs">
                <div class="pilwrap">
                    <a class="pilcrow" href="#section_11">&#182;</a>
                </div>
                <p>Does this make a difference? Yes, it does. Here is an example:</p>

            </td></tr><tr>
            <td class="code">
                <pre><code class='prettyprint lang-scala'>val funnyFun = Map( 'funny -&gt; FunDef(List('a), Add('a,'b)))
assert(evalDynScope(funnyFun, Map.empty, With('b, 3, Call('funny,List(4)))) == 7)

</code></pre>
            </td>
        </tr>
        
        <tr id="section_12">
            <td class="docs">
                <div class="pilwrap">
                    <a class="pilcrow" href="#section_12">&#182;</a>
                </div>
                <p>Obviously this interpreter is &ldquo;buggy&rdquo; in the sense that it does not agree with the substitution-based interpreter. But is this semantics reasonable?</p>
<p>Let's introduce some terminology to make the discussion simpler:</p>
<p><strong>Deﬁnition (Static Scope)</strong>: In a language with static scope, the scope of an identiﬁer’s binding is a syntactically delimited region. A typical region would be the body of a function or other binding construct.</p>
<p><strong>Deﬁnition (Dynamic Scope)</strong>: In a language with dynamic scope, the scope of an identiﬁer’s binding is the entire remainder of the execution during which that binding is in effect.</p>
<p>We see that <code>eval</code> and <code>evalWithEnv</code> give our language static scoping, whereas evalDynScope gives our language dynamic scoping.</p>
<p>Armed with this terminology, we claim that dynamic scope is entirely unreasonable. The problem is that we simply cannot determine what the value of a program will be without knowing everything about its execution history. If the function f were invoked by some other sequence of functions that did not bind a value for n, then that particular application of f would result in an error, even though a previous application of f in the very same program’s execution completed successfully! In other words, simply by looking at the source text of f, it would be impossible to determine one of the most rudimentary properties of a program: whether or not a given identiﬁer was bound. You can only imagine the mayhem this would cause in a large software system, especially with multiple developers and complex ﬂows of control. We will therefore regard dynamic scope as an error</p>

            </td></tr><tr>
            <td class="code">
                <pre><code class='prettyprint lang-scala'></code></pre>
            </td>
        </tr>
        
        </tbody>
    </table>
</div>
</body>
</html>
